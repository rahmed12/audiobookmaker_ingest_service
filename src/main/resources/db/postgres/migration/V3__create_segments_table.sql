-- =====================================================================
-- TABLE: segment
-- PURPOSE: Fine-grained spans (global char offsets into book text) with
--          type + speaker/voice metadata. Idempotent on (book, span, type).
-- OWNER:   langextract-service (UPSERT).
-- =====================================================================
CREATE TABLE IF NOT EXISTS segments (
  id                   BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  book_id              UUID NOT NULL REFERENCES books(id) ON DELETE CASCADE,

  -- Global offsets into the book's TXT (0-based, end-exclusive)
  span_start           INT  NOT NULL CHECK (span_start >= 0),
  span_end             INT  NOT NULL CHECK (span_end > span_start),

  -- Minimal classification (allow NULL during uncertain cases)
  type                 TEXT CHECK ( type IS NULL
                                 OR type IN ('dialogue','narrator','internal_dialogue', 'none') ),

  -- Speaker / voice hints (free text + optional canonical link)
  character_id         UUID REFERENCES characters(id),
  character_name       TEXT,
  character_gender     TEXT DEFAULT 'unknown'
                           CHECK (character_gender IN ('male','female','unknown')),
  character_age_group  TEXT DEFAULT 'unknown'
                           CHECK (character_age_group IN ('child','teen','adult','senior','unknown')),
  prosody              TEXT DEFAULT 'neutral'
                           CHECK (prosody IN ('neutral','whisper','shout','angry','happy','sad','tense','calm','excited')),
  metadata             JSONB,                            -- extra tags/scores

  -- Provenance (helps audits/re-runs)
  source               TEXT DEFAULT 'langextract',
  model_version        TEXT,
  pass_no              INT,

  created_at           TIMESTAMPTZ NOT NULL DEFAULT NOW()

);

-- === Idempotency across overlaps/passes (NO expressions; safe & simple) ===
-- 1) When type IS NOT NULL, key on (book_id, span_start, span_end, type)
CREATE UNIQUE INDEX IF NOT EXISTS uq_seg_book_span_type_notnull
  ON segments (book_id, span_start, span_end, type)
  WHERE type IS NOT NULL;

-- 2) When type IS NULL, key on (book_id, span_start, span_end)
CREATE UNIQUE INDEX IF NOT EXISTS uq_seg_book_span_type_null
  ON segments (book_id, span_start, span_end)
  WHERE type IS NULL;

CREATE INDEX IF NOT EXISTS idx_segment_book_span  ON segments(book_id, span_start);
CREATE INDEX IF NOT EXISTS idx_segment_type       ON segments(book_id, type);
CREATE INDEX IF NOT EXISTS idx_segment_charname   ON segments(book_id, character_name);
CREATE INDEX IF NOT EXISTS idx_segment_charid     ON segments(book_id, character_id);
